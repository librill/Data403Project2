---
title: "scratch"
output: html_document
date: "2025-10-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(dplyr)
```

```{r cars}
# load dataframe
all_credit <- read_csv(here::here("Data", "application_train.csv"))
```

```{r}
nrow(all_credit)
```


```{r}
# aggregate documents flagged, one-hot-encode, and select columns, 
credit <- all_credit %>% 
  mutate(
    DOCUMENTS_FLAGGED = rowSums(select(., starts_with("FLAG_DOCUMENT")))
  ) %>% 
  mutate(
    CONTRACT_TYPE_CASH = ifelse(NAME_CONTRACT_TYPE=="Cash loans", 1, 0), 
    CONTRACT_TYPE_REVOLVING = ifelse(NAME_CONTRACT_TYPE=="Revolving loans", 1, 0),
    EDUCATION_TYPE_SECONDARY = ifelse(NAME_EDUCATION_TYPE=="Secondary / secondary special", 1, 0),
    EDUCATION_TYPE_HIGHER = ifelse(NAME_EDUCATION_TYPE=="Higher education", 1, 0), 
    EDUCATION_TYPE_OTHER = ifelse(!NAME_EDUCATION_TYPE %in% c("Secondary / secondary special", "Higher education"), 1, 0),
    FAMILY_STATUS_MARRIED = ifelse(NAME_FAMILY_STATUS=="Married", 1, 0), 
    FAMILY_STATUS_SINGLE = ifelse(NAME_FAMILY_STATUS=="Single / not married", 1, 0), 
    FAMILY_STATUS_OTHER = ifelse(!NAME_FAMILY_STATUS %in% c("Married", "Single / not married"), 1, 0),
    HOUSING_TYPE_OWN = ifelse(NAME_HOUSING_TYPE=="House / apartment", 1, 0), 
    HOUSING_TYPE_PARENTS = ifelse(NAME_HOUSING_TYPE=="With parents", 1, 0), 
    HOUSING_TYPE_OTHER = ifelse(!NAME_HOUSING_TYPE %in% c("House / apartment", "With parents"), 1, 0), 
    FLAG_OWN_CAR = ifelse(FLAG_OWN_CAR =="Y", 1, 0),
    FLAG_OWN_REALTY = ifelse(FLAG_OWN_REALTY=="Y", 1, 0)
        ) %>%
  select (
    SK_ID_CURR,
    CONTRACT_TYPE_CASH, 
    CONTRACT_TYPE_REVOLVING, 
    FLAG_OWN_CAR,
    FLAG_OWN_REALTY,
    CNT_CHILDREN,
    AMT_INCOME_TOTAL,
    AMT_CREDIT,
    AMT_ANNUITY,
    AMT_GOODS_PRICE,
    EDUCATION_TYPE_SECONDARY, 
    EDUCATION_TYPE_HIGHER, 
    EDUCATION_TYPE_OTHER, 
    FAMILY_STATUS_MARRIED, 
    FAMILY_STATUS_SINGLE, 
    FAMILY_STATUS_OTHER, 
    HOUSING_TYPE_OWN, 
    HOUSING_TYPE_PARENTS, 
    HOUSING_TYPE_OTHER,
    DAYS_EMPLOYED,
    DOCUMENTS_FLAGGED, 
    TARGET
  )

head(credit)
```
```{r}
nrow(credit)
```

LIST OF (new) VARIABLES:

- SK_ID_CURR
- TARGET
- NAME_CONTRACT_TYPE
  -> CONTRACT_TYPE_CASH
  -> CONTRACT_TYPE_REVOLVING
- FLAG_OWN_CAR
- FLAG_OWN_REALTY
- CNT_CHILDREN
- AMT_INCOME_TOTAL
- AMT_CREDIT
- AMT_ANNUITY
- AMT_GOODS_PRICE
- NAME_INCOME_TYPE? 
- NAME_EDUCATION_TYPE
  -> EDUCATION_TYPE_SECONDARY
  -> EDUCATION_TYPE_HIGHER
  -> EDUCATION_TYPE_OTHER
- NAME_FAMILY_STATUS
  -> FAMILY_STATUS_MARRIED
  -> FAMILY_STATUS_SINGLE
  -> FAMILY_STATUS_OTHER
- NAME_HOUSING_TYPE
  -> HOUSING_TYPE_OWN (house / apartment)
  -> HOUSING_TYPE_PARENTS
  -> HOUSING_TYPE_OTHER
- DAYS_EMPLOYED (current job - proxy for age?)
- DOCUMENTS_FLAGGED (aggregate of FLAG_DOCUMENT 2-21)

```{r}
plot_children <- credit |>
  group_by(CNT_CHILDREN) |>
  summarise(default_rate = mean(TARGET)) |>
  ggplot(aes(x = factor(CNT_CHILDREN), y = default_rate, fill = factor(CNT_CHILDREN))) +
  geom_col() +
  labs(title="Default Rate by Number of Children",
       x = "Number of Children",
       y = "Default Rate") +
  theme_bw() +
  theme(legend.position = "none")

plot_children
```

```{r}
# save plot locally, dimensions chosen arbitrarily
ggsave("images/default_children.png", plot=plot_children, width = 10, height = 6)
```

```{r}
plot_education <- credit |>
  mutate(
    Education = factor(case_when(
      EDUCATION_TYPE_HIGHER == 1 ~ "Higher",
      EDUCATION_TYPE_SECONDARY == 1 ~ "Secondary",
      TRUE ~ "Other"
    ), levels = c("Higher", "Secondary", "Other"))
  ) |>
  group_by(Education) |>
  summarise(default_rate = mean(TARGET)) |>
  ggplot(aes(x = Education, y = default_rate, fill = Education)) +
  geom_col() +
  labs(title = "Default Rate by Education Level",
       y = "Default Rate") +
  theme_bw() +
  theme(legend.position = "none")

plot_education
```

```{r}
# save plot locally, dimensions chosen arbitrarily
ggsave("images/default_education.png", plot=plot_education, width = 10, height = 6)
```

```{r}

# function to determine nan values, given dataframe 
# consumes dataframe, returns df of colnames and number nan

# add percent nan function also
count_nan <- function(df) {
  nan_cols <- data.frame()
  
  for (i in 1:ncol(df)) {
    name <- colnames(df[i])
    num_nan <- sum(is.na(df[i]))
    percent <- round(num_nan / ncol(df), 2)
    nan_cols <- rbind(nan_cols, data.frame("column name" = name, "nan values" = num_nan, "percent nan" = percent))
  }
  
  return(nan_cols)
}
```

```{r}
# critera: 
# keep all columns with 0 N/A
# all columns with <= 1% NA: drop those rows
# other columns: remove from the model (too many NA)

# QUESTION: can we make assumptions about WHY some values might be Nan? 

```

```{r}
count_nan(all_credit)

count_nan(credit)
```

```{r}
# Completely Random Sampled Split
# Split data into 70% training
random_split <- function(df, train_prop = 0.7, val_prop = 0.1, seed = 123) {
  set.seed(seed)
  
  df_shuffled <- df |> slice_sample(prop = 1)
  n <- nrow(df_shuffled)
  
  train_n <- floor(train_prop * n)
  val_n   <- floor(val_prop * n)
  
  train <- df_shuffled[1:train_n, ]
  val   <- df_shuffled[(train_n + 1):(train_n + val_n), ]
  test  <- df_shuffled[(train_n + val_n + 1):n, ]
  
  list(train = train, validation = val, test = test)
}

splits <- random_split(all_credit, train_prop = 0.7, val_prop = 0.1)

random_training_set   <- splits$train
random_validation_set <- splits$validation
random_testing_set    <- splits$test

```

```{r}
cat("Size of Training Set:", nrow(random_training_set),"\n",
    "Size of Validation Set:", nrow(random_validation_set),"\n",
    "Size of Testing Set:", nrow(random_testing_set), "\n")
```

We see that there are 24,825 rows where TARGET = 1, and 282,686 rows where TARGET = 0 Thus this ratio is 8.07% "has struggled to repay their loans in the past", 91.93% "any other cases"
We can just say 8% has TARGET = 1, and 92% has TARGET = 0.
For this reason, our stratified sample will produce training sets, validation sets, and testing sets with the amount of observations proportional to what was seen in the data (i.e. .92 class 0 and .08 class 1).

```{r}
# Stratified Random Sample

target <- all_credit |> filter(TARGET == 1)
non_target <- all_credit |> filter(TARGET == 0)

stratified_split <- function(df) {
  n <- nrow(df)
  
  train_n <- floor(0.70 * n)
  val_n <- floor(0.10 * n)
  
  train_idx <- sample(seq_len(n), train_n)
  rest <- df[-train_idx, ]
  
  validation_idx <- sample(seq_len(nrow(rest)), val_n)
  
  train <- df[train_idx, ]
  val   <- rest[validation_idx, ]
  test  <- rest[-validation_idx, ]

  list(train=train, val=val, test=test)
}

split0 <- stratified_split(target)
split1 <- stratified_split(non_target)

straified_training_set   <- bind_rows(split0$train, split1$train) %>% sample_frac(1)
straified_validation_set <- bind_rows(split0$val,   split1$val)   %>% sample_frac(1)
straified_testing_set    <- bind_rows(split0$test,  split1$test)  %>% sample_frac(1)
```

```{r}
prop.table(table(straified_training_set$TARGET))
prop.table(table(straified_validation_set$TARGET))
prop.table(table(straified_testing_set$TARGET))
```

```{r}
# Non-random split
# Possibility 1: Train on older loan -> Test on newer loan applicants?
library(dplyr)
library(ggplot2)
set.seed(123)

time_split <- function(df, train_prop = 0.70, val_prop = 0.10) {
  df_ord <- df %>% arrange(SK_ID_CURR)
  n <- nrow(df_ord)
  train_end <- floor(train_prop * n)
  val_end   <- floor((train_prop + val_prop) * n)

  list(
    train = df_ord[1:train_end, ],
    val   = df_ord[(train_end + 1):val_end, ],
    test  = df_ord[(val_end + 1):n, ]
  )
}

```

```{r}
# Possibility 2: Split on Incomes; train on medium and high income, test on low-income
income_split <- function(df, val_prop_within_train = 0.20, seed = 123) {
  set.seed(seed)
  q <- quantile(df$AMT_INCOME_TOTAL, probs = c(1/3, 2/3), na.rm = TRUE)
  low  <- df %>% filter(AMT_INCOME_TOTAL <  q[1])
  mid  <- df %>% filter(AMT_INCOME_TOTAL >= q[1], AMT_INCOME_TOTAL <  q[2])
  high <- df %>% filter(AMT_INCOME_TOTAL >= q[2])

  trainval <- bind_rows(mid, high) %>% slice_sample(prop = 1)
  n_tv <- nrow(trainval)
  val_n <- floor(val_prop_within_train * n_tv)

  val_idx <- sample(seq_len(n_tv), size = val_n)
  val  <- trainval[val_idx, ]
  train <- trainval[-val_idx, ]

  test <- low %>% slice_sample(prop = 1)

  list(train = train, val = val, test = test)
}

```

```{r}
# Possibility #3: Split on Employment Type; Train on "old" employment types and 
# train on "newer" employment types
loan_type_split <- function(df, val_prop_within_train = 0.20, use_cash_for_train = TRUE, seed = 123) {
  set.seed(seed)
  cash      <- df %>% filter(CONTRACT_TYPE_CASH == 1)
  revolving <- df %>% filter(CONTRACT_TYPE_REVOLVING == 1)

  if (use_cash_for_train) {
    trainval <- cash %>% slice_sample(prop = 1)
    test     <- revolving %>% slice_sample(prop = 1)
  } else {
    trainval <- revolving %>% slice_sample(prop = 1)
    test     <- cash %>% slice_sample(prop = 1)
  }

  n_tv <- nrow(trainval)
  val_n <- floor(val_prop_within_train * n_tv)
  val_idx <- sample(seq_len(n_tv), size = val_n)

  val   <- trainval[val_idx, ]
  train <- trainval[-val_idx, ]

  list(train = train, val = val, test = test)
}

```


